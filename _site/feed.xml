<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KevinHuang Blog</title>
    <description>关于前端与设计、黑客与画家 | 黄玄，Web &amp; Mobile Lover，Front-End Engineer，UX Designer | 这里是 @Hux黄玄 的个人博客，与你一起发现更大的世界。</description>
    <link>http://huangxuan.me/</link>
    <atom:link href="http://huangxuan.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 31 Jul 2017 18:52:44 +0800</pubDate>
    <lastBuildDate>Mon, 31 Jul 2017 18:52:44 +0800</lastBuildDate>
    <generator>Jekyll v2.5.0</generator>
    
      <item>
        <title>google开源python代码规范</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;1. 行长度&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;每行不超过80个字符(例外 a.长的导入模块语句; b. 注释里的url)&lt;/li&gt;
      &lt;li&gt;Python会将 圆括号, 中括号和花括号中的行隐式的连接起来 ：
        &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;In [2]: print(&#39;hello&#39;
 ...: &#39;world&#39;)
helloworld
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2. 文件和sockets&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;在文件和sockets结束时, 显式的关闭它.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;推荐使用 “with”语句 以管理文件;&lt;/li&gt;
      &lt;li&gt;对于不支持使用”with”语句的类似文件的对象,使用 contextlib.closing():
        &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import contextlib
with contextlib.closing(urllib.urlopen(&quot;http://www.python.org/&quot;)) as front_page:
for line in front_page:
    print line
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;3. todo注释&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;4. 导入格式&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;每个导入应该独占一行&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;导入顺序：
        &lt;ul&gt;
          &lt;li&gt;标准库导入&lt;/li&gt;
          &lt;li&gt;第三方库导入&lt;/li&gt;
          &lt;li&gt;应用程序指定导入&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;5. 命名约定&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.&lt;/li&gt;
      &lt;li&gt;用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含).&lt;/li&gt;
      &lt;li&gt;用双下划线(__)开头的实例变量或方法表示类内私有.&lt;/li&gt;
      &lt;li&gt;将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.&lt;/li&gt;
      &lt;li&gt;对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 01 Aug 2017 01:49:32 +0800</pubDate>
        <link>http://huangxuan.me/2017/08/01/google-opensourse-python-code-standard/</link>
        <guid isPermaLink="true">http://huangxuan.me/2017/08/01/google-opensourse-python-code-standard/</guid>
        
        
      </item>
    
      <item>
        <title>docker学习总结</title>
        <description>
&lt;p&gt;后台守护进程启动docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
docker run --name uc -p 8001:8001 -tdi python-jlb /bin/bash

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入后台运行的docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
docker attach docker-name

&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Thu, 06 Jul 2017 16:02:37 +0800</pubDate>
        <link>http://huangxuan.me/%E5%85%B6%E5%AE%83/2017/07/06/dockere5ada6e4b9a0e680bbe7bb93/</link>
        <guid isPermaLink="true">http://huangxuan.me/%E5%85%B6%E5%AE%83/2017/07/06/dockere5ada6e4b9a0e680bbe7bb93/</guid>
        
        <category>docker</category>
        
        
        <category>其它</category>
        
      </item>
    
      <item>
        <title>生成PDF文档</title>
        <description>
&lt;p&gt;主要使用pdfkit模块：&lt;br /&gt;
1.安装pdfkit：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
$ pip install pdfkit
$ sudo apt-get install wkhtmltopdf

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用pdfkit的一些高级功能需要研究wkhtmltopdf的一些功能：&lt;br /&gt;
Warning! Version in debian/ubuntu repos have reduced functionality (because it compiled without the wkhtmltopdf QT patches), such as adding outlines, headers, footers, TOC etc. To use this options you should install static binary from wkhtmltopdf site or you can use this script.&lt;/p&gt;

&lt;p&gt;使用高级功能需要执行以下脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#!/bin/sh
sudo apt-get install -y openssl build-essential xorg libssl-dev
wget http://wkhtmltopdf.googlecode.com/files/wkhtmltopdf-0.10.0_rc2-static-amd64.tar.bz2
tar xvjf wkhtmltopdf-0.10.0_rc2-static-amd64.tar.bz2
sudo chown root:root wkhtmltopdf-amd64

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.基本原理功能：&lt;br /&gt;
Pdfkit文档链接：https://pypi.python.org/pypi/pdfkit&lt;br /&gt;
Pdfkit可以渲染url，file，string 成pdf文档，也支持多个file生产一个pdf文档&lt;/p&gt;

&lt;p&gt;Notices：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;pdf正文部分字体调整： css部分：@font-face {	}中添加font-family等字体属性；&lt;/li&gt;
  &lt;li&gt;页脚的添加： views.py中 print_entrust()函数中options{}字典里边添加footer-center等属性；&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Wed, 05 Jul 2017 10:32:47 +0800</pubDate>
        <link>http://huangxuan.me/%E5%85%B6%E5%AE%83/2017/07/05/e7949fe68890pdfe69687e6a1a3/</link>
        <guid isPermaLink="true">http://huangxuan.me/%E5%85%B6%E5%AE%83/2017/07/05/e7949fe68890pdfe69687e6a1a3/</guid>
        
        <category>PDF</category>
        
        
        <category>其它</category>
        
      </item>
    
      <item>
        <title>web站点相关解决方案</title>
        <description>
&lt;p&gt;邮箱或手机验证码存储解决方案：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用web框架自带的缓存系统，比如django中自带的cache&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;
from django.core import cache
cache.set(&#39;key&#39;, &#39;value&#39;, 10)  #键,值和过期时间
cache.get(&#39;key&#39;, &#39;not fount or has expired&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;使用redis存储:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;
redis_db = RedisDB()
redis_db.set(phone=username, val=code, ex=60*10)

&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Thu, 22 Jun 2017 15:49:32 +0800</pubDate>
        <link>http://huangxuan.me/django/python/2017/06/22/webe7ab99e782b9e79bb8e585b3e8a7a3e586b3e696b9e6a188/</link>
        <guid isPermaLink="true">http://huangxuan.me/django/python/2017/06/22/webe7ab99e782b9e79bb8e585b3e8a7a3e586b3e696b9e6a188/</guid>
        
        <category>django rest framework</category>
        
        <category>python</category>
        
        
        <category>django</category>
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Python LEGN作用域总结</title>
        <description>
&lt;p&gt;LEGB规则&lt;/p&gt;

&lt;p&gt;Python2.2开始引入嵌套函数，嵌套函数为python提供了闭包实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

a = 1
def foo():
   a = 2
   def bar():
        print a  //[1]
    return bar
 
func = foo()
func()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数bar和a=2捆包在一起组成一个闭包，因此这里a=2即使脱离了foo所在的local作用域，但调用func的时候（其实就是调用bar）查找名字a的顺序是LEGB规则，这里的E就是enclosing的缩写，代表的“直接外围作用域”这个概念。查找a时，在bar对应的local作用域中没有时，然后在它外围的作用域中查找a。LEGB规定了查找一个名称的顺序为：local–&amp;gt;enclosing–&amp;gt;global–&amp;gt;builtin。&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Jun 2017 20:49:12 +0800</pubDate>
        <link>http://huangxuan.me/python/%E5%85%B6%E5%AE%83/2017/06/19/python-legne4bd9ce794a8e59f9fe680bbe7bb93/</link>
        <guid isPermaLink="true">http://huangxuan.me/python/%E5%85%B6%E5%AE%83/2017/06/19/python-legne4bd9ce794a8e59f9fe680bbe7bb93/</guid>
        
        
        <category>python</category>
        
        <category>其它</category>
        
      </item>
    
      <item>
        <title>matplotlib RuntimeError: Python is not installed as a framework 错误解决方案</title>
        <description>
&lt;p&gt;在virtualenv环境下使用matplotlib绘图时遇到了这样的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;import matplotlib.pyplot as plt&lt;br /&gt;
Traceback (most recent call last):&lt;br /&gt;
File “”, line 1, in &lt;br /&gt;
…&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;in &lt;br /&gt;
from matplotlib.backends import _macosx&lt;br /&gt;
RuntimeError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are Working with Matplotlib in a virtual enviroment see ‘Working with Matplotlib in Virtual environments’ in the Matplotlib FAQ&lt;/p&gt;

&lt;p&gt;似乎是因为虚拟环境与默认环境的安装配置不同造成的。&lt;/p&gt;

&lt;p&gt;搜索错误信息之后，在STO上找到了解决方案：&lt;/p&gt;

&lt;p&gt;1、pip安装matplotlib之后，会在根目录下产生一个.matplotlib的目录:&lt;/p&gt;

&lt;p&gt;➜ bin ll ~/.matplotlib&lt;br /&gt;
total 280&lt;br /&gt;
-rw-r–r– 1 me staff 78K 10 4 2015 fontList.cache&lt;br /&gt;
-rw-r–r– 1 me staff 59K 1 17 15:56 fontList.py3k.cache&lt;br /&gt;
drwxr-xr-x 2 me staff 68B 10 4 2015 tex.cache&lt;/p&gt;

&lt;p&gt;2、在这个目录下创建一个名为matplotlibrc的文件，内容是：&lt;/p&gt;

&lt;p&gt;backend: TkAgg&lt;/p&gt;

&lt;p&gt;然后保存退出，重启Python交互界面或重新运行脚本，import正常执行。&lt;/p&gt;

&lt;p&gt;STO答案地址：http://stackoverflow.com/questions/21784641/installation-issue-with-matplotlib-python&lt;/p&gt;

</description>
        <pubDate>Thu, 25 May 2017 15:38:27 +0800</pubDate>
        <link>http://huangxuan.me/python/2017/05/25/matplotlib-runtimeerror-python-is-not-installed-as-a-framework-e99499e8afafe8a7a3e586b3e696b9e6a188/</link>
        <guid isPermaLink="true">http://huangxuan.me/python/2017/05/25/matplotlib-runtimeerror-python-is-not-installed-as-a-framework-e99499e8afafe8a7a3e586b3e696b9e6a188/</guid>
        
        <category>framework</category>
        
        <category>python</category>
        
        <category>RuntimeError</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>casperjs传参</title>
        <description>
&lt;p&gt;casperjs传递动态参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var casper = require(&#39;casper&#39;).create({
    pageSettings: {
     javascriptEnabled: true ,
     loadImages: true,
     loadPlugins: true,
     userAgent: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#39;
    },
    // logLevel: &quot;debug&quot;,//日志等级
    // verbose: true,  // 记录日志到控制台
     viewportSize: {width: 1024, height: 768}
});

var args2 = casper.cli.args;

var NET_SessionId = args2[0];
var EhireGuid = args2[1];
var AccessKey = args2[2];
var HRUSERINFO = args2[3];

&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 18 Apr 2017 10:52:32 +0800</pubDate>
        <link>http://huangxuan.me/%E7%88%AC%E8%99%AB/2017/04/18/casperjse4bca0e58f82/</link>
        <guid isPermaLink="true">http://huangxuan.me/%E7%88%AC%E8%99%AB/2017/04/18/casperjse4bca0e58f82/</guid>
        
        <category>casperjs</category>
        
        <category>爬虫</category>
        
        
        <category>爬虫</category>
        
      </item>
    
      <item>
        <title>casperjs截取验证码图片和设置cookies，headers，模拟鼠标点击selected元素</title>
        <description>
&lt;p&gt;casperjs设置headers：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var casper = require(&#39;casper&#39;).create({
    pageSettings: {
     loadImages: true,
     loadPlugins: true,
     // userAgent: &#39;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER&#39;
     userAgent: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#39;,
    }
     logLevel: &quot;debug&quot;,//日志等级
     verbose: true  // 记录日志到控制台
});

var mouse = require(&quot;mouse&quot;).create(casper);

var url = &#39;http://baidu.com/&#39;;

casper.start(url);

// casper.thenClick(&#39;#verify-state&#39;);    //鼠标点击
casper.thenClick(&#39;#btnBeginValidate&#39;);
casper.thenClick(&#39;#btnVRefresh&#39;,function(response){
    this.echo((response.headers.get(&#39;Set-Cookie&#39;)).split(&#39;;&#39;)[0]);   #获取响应的Set-Cookie信息
});

casper.then(function () {

    // this.echo(this.)
    // this.querySelector(&#39;img[id=&quot;imgPhrase&quot;]&#39;).setAttribute(&#39;style&#39;, &quot;display: block&quot;);
    this.wait(1000, function () {
        img_guid = this.getElementAttribute(&#39;img[id=&quot;imgPhrase&quot;]&#39;, &#39;src&#39;);  //获取元素属性值
        // img_name = img_guid + &#39;.png&#39;;
        img_name = &#39;2001.png&#39;;
        this.captureSelector(img_name, &#39;.yz-main&#39;);   # 根据元素属性截取图片
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;casperjs设置cookies：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var webPage = require(&#39;webpage&#39;);
var page = webPage.create();

page.customHeaders = {
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#39;,
    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;
};

if (phantom.addCookie({
    &#39;name&#39;: &#39;EhireGuid&#39;,
    &#39;value&#39;: &#39;5662e8a3df3c4062aa9edd9ee3e2e36f&#39;,
    &#39;path&#39;: &#39;/&#39;,   //必须
    &#39;domain&#39;: &#39;baidu.com&#39;   //必须
})) {console.log(&#39;cookie EhireGuid success&#39;)} else {
    console.log(&#39;cookie EhireGuid fail&#39;)       //一直返回失败，但是实际上是成功了，感觉这个是phantomjs的bug 有空提交一下bug
}

var selector = &quot;#dropPutDateRange&quot;; // use proper selector

casper.then(function(){
    // check selectd value
        var selected = this.evaluate(function(selector){
            var s = document.querySelector(selector);
            var o = s.children[s.selectedIndex];
            return {value: o.value, text: o.innerHTML};
        }, selector);

        this.echo(&quot;result: &quot; + JSON.stringify(selected, undefined, 4));   //打印selected的值

        this.evaluate(function() {
            $(&#39;#dropPutDateRange &#39;).val(&#39;value&#39;).change();   //改变selected的值
        });
});

casper.run();

&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 14 Apr 2017 18:32:48 +0800</pubDate>
        <link>http://huangxuan.me/%E7%88%AC%E8%99%AB/2017/04/14/casperjse688aae58f96e9aa8ce8af81e7a081e59bbee78987e5928ce8aebee7bdaecookiesefbc8cheadersefbc8ce6a8a1e68b9fe9bca0e6a087e782b9e587bbselected/</link>
        <guid isPermaLink="true">http://huangxuan.me/%E7%88%AC%E8%99%AB/2017/04/14/casperjse688aae58f96e9aa8ce8af81e7a081e59bbee78987e5928ce8aebee7bdaecookiesefbc8cheadersefbc8ce6a8a1e68b9fe9bca0e6a087e782b9e587bbselected/</guid>
        
        <category>casperjs</category>
        
        <category>cookie</category>
        
        <category>截图</category>
        
        <category>验证码</category>
        
        
        <category>爬虫</category>
        
      </item>
    
      <item>
        <title>Python中的一些魔法</title>
        <description>
&lt;p&gt;1.将多个序列串放在一起遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;gt;&amp;gt;&amp;gt; from itertools import chain  
&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4]  
&amp;gt;&amp;gt;&amp;gt; b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]  
&amp;gt;&amp;gt;&amp;gt; for x in chain(a, b):  
...     print(x)  
...   

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.python表示昨天的日期：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#-*-coding:utf-8-*-  
import datetime

def getYesterday():   #
   today=datetime.date.today()  
   oneday=datetime.timedelta(days=1)  
   yesterday=today-oneday   
   return yesterday

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.打印代码出错信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
import traceback
traceback.format_exc()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;traceback.print_exc()跟traceback.format_exc()有什么区别呢？&lt;br /&gt;
format_exc()返回字符串，print_exc()则直接给打印出来。&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Jan 2017 16:27:21 +0800</pubDate>
        <link>http://huangxuan.me/python/2017/01/23/pythone4b8ade79a84e4b880e4ba9be9ad94e6b395/</link>
        <guid isPermaLink="true">http://huangxuan.me/python/2017/01/23/pythone4b8ade79a84e4b880e4ba9be9ad94e6b395/</guid>
        
        <category>Magic</category>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>js提交数据的headers设置</title>
        <description>
&lt;p&gt;JS通过ajax提交post数据有两种方式：Request Payload 和 Form Data，具体的区分可以通过设置请求头的Content-Type来确定：&lt;/p&gt;

&lt;p&gt;需要Form Data方式提交数据可以设置headers = {‘Content-Type’:’application/x-www-form-urlencoded’}&lt;/p&gt;

&lt;p&gt;需要Request Payload方式提交数据可以设置headers = {‘contentType’:’text/plain;charset=UTF-8’}&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Jan 2017 18:54:21 +0800</pubDate>
        <link>http://huangxuan.me/django/python/2017/01/03/jse68f90e4baa4e695b0e68daee79a84headerse8aebee7bdae/</link>
        <guid isPermaLink="true">http://huangxuan.me/django/python/2017/01/03/jse68f90e4baa4e695b0e68daee79a84headerse8aebee7bdae/</guid>
        
        <category>python</category>
        
        <category>前端js</category>
        
        
        <category>django</category>
        
        <category>python</category>
        
      </item>
    
  </channel>
</rss>
